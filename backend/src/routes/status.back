// backend/src/routes/status.ts
import { readFileSync, existsSync, readdirSync, appendFileSync, mkdirSync } from "node:fs";
import { resolve, join } from "node:path";

// ---------- helpers ----------
function loadJson<T>(p: string, fallback: T): T {
  try { if (existsSync(p)) return JSON.parse(readFileSync(p, "utf-8")) as T; } catch {}
  return fallback;
}

type Zone = { id: string; name: string; deck: number; stream: "human" | "plant"; [k: string]: any };
type Crew = { id: string; name: string; zoneId: string; phase: string; driftMin: number };

const CFG_DIR     = resolve(process.cwd(), "..", "config");   // <repo>/config
const ZONES_DIR   = join(CFG_DIR, "zones");                   // <repo>/config/zones/*.json
const ROSTER_PATH = join(CFG_DIR, "roster.json");             // <repo>/config/roster.json

function loadZonesFromFolder(dir: string): Zone[] {
  if (!existsSync(dir)) return [];
  const files = readdirSync(dir).filter(f => f.toLowerCase().endsWith(".json"));
  const out: Zone[] = [];
  for (const f of files) {
    const p = join(dir, f);
    const data = loadJson<any>(p, []);
    if (Array.isArray(data)) out.push(...data);
    else if (data && typeof data === "object") {
      if (Array.isArray((data as any).zones)) out.push(...(data as any).zones);
      else if ((data as any).id && (data as any).name) out.push(data as Zone);
    }
  }
  return out;
}

// ---------- illumination helpers (Build 6) ----------
type IllumMode = "Sunlit" | "PreDark" | "Dark" | "ReLight";
type IllumMask = { stepHours: number; samples: { lit: 0 | 1 }[] }; // 30 days * (24/stepHours)
type DarkWin = { startTod: number; endTod: number };

/**
 * Fallback synthetic 30d hourly mask if nothing is provided by /illumination/30d.
 * - Mostly Sunlit
 * - PreDark/Dark windows toward the end of each day (short)
 * - Day ~14 has extra short dark slivers to demo micro-dark
 */
function buildSyntheticMask(stepHours = 1): IllumMask {
  const stepsPerSol = Math.round(24 / stepHours);
  const totalDays = 30;
  const samples: { lit: 0 | 1 }[] = [];

  for (let d = 0; d < totalDays; d++) {
    for (let i = 0; i < stepsPerSol; i++) {
      const tod = i / stepsPerSol; // 0..1
      // base: dark from 0.83..0.95 (≈ 17% of the day)
      const darkBase = tod >= 0.83 && tod < 0.95;
      // micro-dark extras around day ~14 (show multiple thin windows)
      const micro =
        d >= 13 && d <= 15 && (
          (tod >= 0.28 && tod < 0.30) || (tod >= 0.48 && tod < 0.495) || (tod >= 0.62 && tod < 0.635)
        );
      const lit = darkBase || micro ? 0 : 1;
      samples.push({ lit: lit as 0 | 1 });
    }
  }
  return { stepHours, samples };
}

// Extract today’s dark windows for given sol (0..29)
function darkWindowsForDay(mask: IllumMask, sol: number): DarkWin[] {
  const step = mask.stepHours || 1;
  const stepsPerSol = Math.round(24 / step);
  const start = sol * stepsPerSol;
  const end = start + stepsPerSol;
  const day = mask.samples.slice(start, end);

  const wins: DarkWin[] = [];
  let i = 0;
  while (i < day.length) {
    if (day[i].lit === 0) {
      const s = i;
      while (i < day.length && day[i].lit === 0) i++;
      const e = i;
      wins.push({ startTod: (s * step) / 24, endTod: (e * step) / 24 });
    } else {
      i++;
    }
  }
  return wins;
}

// Minutes until next dark window (0 if currently dark; null if none ahead today)
function minutesUntilNextDark(tod: number, wins: DarkWin[]) {
  if (wins.some(w => tod >= w.startTod && tod < w.endTod)) return 0;
  const ahead = wins.map(w => w.startTod).filter(s => s > tod).sort((a, b) => a - b);
  if (ahead.length === 0) return null;
  const deltaDays = ahead[0] - tod;
  return Math.max(0, Math.round(deltaDays * 24 * 60));
}

// ---------- simple energy model (tunable) ----------
function greenhouseCanopyKW(area_m2: number, ppfd: number, efficacy_umol_per_J: number) {
  const watts = (ppfd * area_m2) / efficacy_umol_per_J;
  return watts / 1000; // kW
}

function humanZonesKW(numZones: number, fixturesPerZone: number, fixtureW: number, intensity: number) {
  const perZoneW = fixturesPerZone * fixtureW * intensity;
  return (numZones * perZoneW) / 1000;
}

function overlayKW(canopyKW: number, frac: number) {
  return canopyKW * Math.min(0.10, Math.max(0, frac)); // ≤10%
}

function applyMargin(kW: number, frac = 0.12) {
  return kW * (1 + frac);
}

export default async function statusRoutes(fastify: any) {
  fastify.get("/status", async () => {
    const now = new Date();

    // Real tod for timeline/clock (0..1 across 24h)
    const todReal = ((now.getUTCHours() * 60 + now.getUTCMinutes()) / (24 * 60));

    // Demo clock for fast energy/mode cycling (0..1 each minute)
    const sec = now.getSeconds() + now.getMilliseconds() / 1000;
    const todDemo = sec / 60;

    // load config-driven topology
    const zones  = loadZonesFromFolder(ZONES_DIR);
    const roster = loadJson<{ crew: Crew[] }>(ROSTER_PATH, { crew: [] });

    // ----- ENERGY INPUTS (edit here to tune) -----
    const HUMAN_ZONES = zones.filter(z => z.stream === "human").length || 12;
    const FIXTURES_PER_ZONE = 3;
    const HUMAN_FIXTURE_W = 45;          // W per fixture
    const GH_AREA_M2 = 10;               // greenhouse canopy area
    const GH_EFFICACY = 2.6;             // µmol/J
    const ALGAE_KW = 0.25;               // steady lighting for algae
    const OVERLAY_FRAC = 0.0;            // 0..0.10 (hook to /lights/plan overlays later)

    // Illumination mode from demo day (fast animation)
    const illumMode: IllumMode =
      (todDemo < 0.05 || todDemo >= 0.95) ? "ReLight" :
      (todDemo < 0.75)                    ? "Sunlit" :
      (todDemo < 0.83)                    ? "PreDark" :
      (todDemo < 0.95)                    ? "Dark"    : "ReLight";

    // Human intensity (cosine across the day): 0.30..0.60
    const phase = 2 * Math.PI * todDemo;
    const humanIntensity = Math.max(0.30, Math.min(0.60, 0.45 + 0.15 * Math.cos(phase - Math.PI / 3)));

    // Greenhouse canopy by mode (kept explicit for readability)
    const ppfd =
      illumMode === "PreDark" ? 300 :
      illumMode === "Dark"    ? 100 :
      illumMode === "ReLight" ? 280 : 250;

    const greenhouseKW = greenhouseCanopyKW(GH_AREA_M2, ppfd, GH_EFFICACY);
    const humanKW      = humanZonesKW(HUMAN_ZONES, FIXTURES_PER_ZONE, HUMAN_FIXTURE_W, humanIntensity);
    const overlaysKW   = overlayKW(greenhouseKW, OVERLAY_FRAC);

    // Subtotal + margin
    const subtotalKW = humanKW + greenhouseKW + ALGAE_KW + overlaysKW;
    const totalKW    = applyMargin(subtotalKW, 0.12);

    // ---- plantZones synthesis (three zones: MicroGreens, Sprouts, Algae) ----
    const MG_AREA_M2 = 6;  // MicroGreens
    const SP_AREA_M2 = 4;  // Sprouts

    const MG_DLI_TARGET = 10;
    const SP_DLI_TARGET = 8;
    const AL_DLI_TARGET = 5;

    const mg_ppfdSet = ppfd;
    const sp_ppfdSet = Math.max(180, Math.min(260, ppfd - 20));
    const al_ppfdSet = 150;

    const mg_kW = greenhouseCanopyKW(MG_AREA_M2, mg_ppfdSet, GH_EFFICACY);
    const sp_kW = greenhouseCanopyKW(SP_AREA_M2, sp_ppfdSet, GH_EFFICACY);

    const secondsPerDay = 86400;
    // Use real day fraction (todReal) so DLI fills over the actual day, not each minute
    const mg_dli_so_far = (mg_ppfdSet * todReal * secondsPerDay) / 1e6;
    const sp_dli_so_far = (sp_ppfdSet * todReal * secondsPerDay) / 1e6;
    const al_dli_so_far = (al_ppfdSet * todReal * secondsPerDay) / 1e6;

    const plantZones = [
      {
        id: "microgreens",
        name: "MicroGreens",
        ppfdSet: mg_ppfdSet,
        ppfdNow: mg_ppfdSet,
        dliTarget: MG_DLI_TARGET,
        dliProgress: Number(Math.max(0, Math.min(1, mg_dli_so_far / MG_DLI_TARGET)).toFixed(2)),
        energyKW: Number(mg_kW.toFixed(2)),
        overlay: { on: OVERLAY_FRAC > 0, untilUtc: null }
      },
      {
        id: "sprouts",
        name: "Sprouts",
        ppfdSet: sp_ppfdSet,
        ppfdNow: sp_ppfdSet,
        dliTarget: SP_DLI_TARGET,
        dliProgress: Number(Math.max(0, Math.min(1, sp_dli_so_far / SP_DLI_TARGET)).toFixed(2)),
        energyKW: Number(sp_kW.toFixed(2)),
        overlay: { on: OVERLAY_FRAC > 0, untilUtc: null }
      },
      {
        id: "algae",
        name: "Algae Bioreactor",
        ppfdSet: al_ppfdSet,
        ppfdNow: al_ppfdSet,
        dliTarget: AL_DLI_TARGET,
        dliProgress: Number(Math.max(0, Math.min(1, al_dli_so_far / AL_DLI_TARGET)).toFixed(2)),
        energyKW: Number(ALGAE_KW.toFixed(2)),
        overlay: { on: false, untilUtc: null }
      }
    ];

    // ---------- Build 6: micro-dark windows + countdown ----------
    // Prefer mask provided by illumination plugin; otherwise synthesize.
    // Expectation: illuminationRoutes decorates fastify with `illumMask` (if implemented there).
    const mask: IllumMask =
      fastify.illumMask && fastify.illumMask.stepHours ? fastify.illumMask :
      buildSyntheticMask(1);

    // For now we keep a fixed sol of 12 (your current status response). If you later compute sol, plug it in here.
    const sol = 12;
    const darkWindowsToday = darkWindowsForDay(mask, sol);
    const nextDarkInMin = minutesUntilNextDark(todReal, darkWindowsToday);

    // ---------- Build 6: presence overlay on crew ----------
    const baseCrew = (roster.crew ?? []).slice(0, 2);
    const applyPresence = (crew: Crew[]) => {
      if (!fastify.getPresenceZone) return crew;
      return crew.map(c => {
        const ovr = fastify.getPresenceZone(c.id);
        return ovr ? { ...c, zoneId: ovr } as Crew : c;
      });
    };
    const crew = applyPresence(baseCrew);

    return {
      time:  { utc: now.toISOString(), local: now.toLocaleTimeString("en-US", { hour12: false }), sol, tod: todReal },
      lunar: { pct: 72, daysRemaining: 19 },
      energy: {
        kw: Number(totalKW.toFixed(2)),
        breakdown: {
          humanKW: Number(humanKW.toFixed(2)),
          greenhouseKW: Number(greenhouseKW.toFixed(2)),
          algaeKW: Number(ALGAE_KW.toFixed(2)),
          overlaysKW: Number(overlaysKW.toFixed(2)),
          marginKW: Number((totalKW - subtotalKW).toFixed(2))
        },
        mode: illumMode,
        humanIntensity: Number(humanIntensity.toFixed(2))
      },
      zones,
      crew,
      plantZones,
      // NEW:
      illum: {
        nextDarkInMin,                   // minutes to next window (0 if currently dark; null if none)
        darkWindowsToday                 // [{ startTod, endTod }]
      }
    };
  });
}
